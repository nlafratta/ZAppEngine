<#@ template language="C#" linePragmas="false" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Zirpl.AppEngine.VisualStudioAutomation.AppGeneration.TextTemplating" #>
<#@ import namespace="Zirpl.AppEngine.VisualStudioAutomation.TextTemplating" #>
<#@ import namespace="Zirpl.AppEngine.VisualStudioAutomation.AppGeneration.Model" #>
<#@ parameter type="Zirpl.AppEngine.VisualStudioAutomation.AppGeneration.Model.App" name="App" #>
<#@ parameter type="Zirpl.AppEngine.VisualStudioAutomation.TextTemplating.OutputInfo" name="OutputInfo" #>
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Data.Entity.Core.Objects;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Reflection;
using Zirpl.AppEngine;
using Zirpl.AppEngine.Model;
using Zirpl.AppEngine.Session;
using Zirpl.AppEngine.Validation;
using Zirpl.Logging;

namespace <#= this.Namespace #>
{
    public abstract partial class <#= this.TypeName #> : global::System.Data.Entity.DbContext
    {
        public IValidationHelper ValidationHelper { get; set; }
        public ICurrentUserKeyProvider CurrentUserKeyProvider { get; set; }
        public IRetryPolicyFactory RetryPolicyFactory { get; set; }

		protected <#= this.TypeName #>()
		{
			this.Database.Log = s => this.GetLog().Debug(s);
		}
        
        //protected override void OnModelCreating(DbModelBuilder modelBuilder)
        //{
        //    base.OnModelCreating(modelBuilder);

        //    this.GetObjectContext().Connection.Open();
        //}

        protected virtual bool IsModifiable(Object obj)
		{
			return true;
		}
    
        public override int SaveChanges()
        {
            // make sure we aren't trying to work with any objects that shouldn't be persisted through EF
            //
            var objStateEntries = this.GetObjectContext().ObjectStateManager.GetObjectStateEntries(
                EntityState.Added | EntityState.Modified | EntityState.Deleted);
            foreach (ObjectStateEntry entry in objStateEntries)
            {
                if (!this.IsModifiable(entry.Entity))
                {
                    throw new Exception(String.Format("Cannot persist entity type directly through DbContext: {0}", entry.Entity.GetType()));
                }
            }

            // call OnSaveChanges to set the automatic properties
            //
            objStateEntries = this.GetObjectContext().ObjectStateManager.GetObjectStateEntries(
               EntityState.Added | EntityState.Modified);

            foreach (ObjectStateEntry entry in objStateEntries)
            {
                this.OnSaveChanges(entry);
            }

            // Retry Save if specified
            //
            return this.RetryPolicyFactory != null
                ? this.RetryPolicyFactory.CreateRetryPolicy().ExecuteAction<int>(base.SaveChanges)
                : base.SaveChanges();
        }

        protected virtual void OnSaveChanges(ObjectStateEntry entry)
        {
            DateTime now = DateTime.Now;
            var auditable = entry.Entity as IAuditable;
            if (auditable != null)
            {
                auditable.UpdatedDate = now;
                var id = this.CurrentUserKeyProvider.GetCurrentUserKey();
                String idAsString = id == null ? null : id.ToString();
                auditable.UpdatedUserId = idAsString;
                if (entry.State == EntityState.Added)
                {
                    auditable.CreatedDate = now;
                    auditable.CreatedUserId = idAsString;
                }
            }

            // this block rejects ALL changes to properties where the old and new values are the same
            // as otherwise SQL could be run that attempts to update a column to the same value.
            // This will fail in cases where Update has been denied on that column
            //
            if (entry.State == EntityState.Modified)
            {
                foreach (var propertyName in entry.GetModifiedProperties())
                {
                    if (Object.Equals(entry.OriginalValues[propertyName], entry.CurrentValues[propertyName]))
                    {
                        entry.RejectPropertyChanges(propertyName);
                    }
                }
            }
        }


        protected override DbEntityValidationResult ValidateEntity(DbEntityEntry entityEntry, IDictionary<object, object> items)
        {
            List<DbValidationError> errors = new List<DbValidationError>();

            //if (entityEntry.State == EntityState.Added
            //    || entityEntry.State == EntityState.Modified)
            //{
                if (this.ValidationHelper != null)
                {
                    if (this.ValidationHelper.IsValidatable(entityEntry))
                    {
                        foreach (var error in this.ValidationHelper.Validate(entityEntry))
                        {
                            errors.Add(new DbValidationError(error.PropertyName, error.ErrorMessage));
                        }
                    }
                }
            //}
            errors.AddRange(base.ValidateEntity(entityEntry, items).ValidationErrors);

            return new DbEntityValidationResult(entityEntry, errors);
        }

        public ObjectContext GetObjectContext()
        {
            return ((IObjectContextAdapter) this).ObjectContext;
        }

		protected override void OnModelCreating(DbModelBuilder modelBuilder)
		{
            modelBuilder.Configurations.AddFromAssembly(Assembly.GetExecutingAssembly());
			
			this.OnOnModelCreating(modelBuilder);

            base.OnModelCreating(modelBuilder);
		}

		partial void OnOnModelCreating(DbModelBuilder modelBuilder);
    }
}
<#+
public string Namespace { get { return ((DotNetTypeOutputInfo)this.OutputInfo).Namespace; } }
public string TypeName { get { return ((DotNetTypeOutputInfo)this.OutputInfo).TypeName; } }
#>